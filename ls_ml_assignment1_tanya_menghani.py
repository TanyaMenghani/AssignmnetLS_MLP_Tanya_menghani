# -*- coding: utf-8 -*-
"""LS_ML_Assignment1_tanya_menghani.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zrPI9kqn8KnVLbbKJoZiYKuYFNo0F6uN
"""
##Q1
import numpy as np
a = np.random.randint(1,51,size=(5,4))
print(a)
n = np.array([0,1,2,3])
for f in n:
  print(a[f,3-f])

print(np.max(a,axis=1))

p=np.mean(a)
print(p)
b= a[a<p]
print(b)

def numpy_boundary_traverse(matrix):
  r=[]
  r.extend(matrix[0,:3].tolist())
  r.extend(matrix[:4,3].tolist())
  r.extend(matrix[4,1:4][::-1].tolist())
  r.extend(matrix[1:5,0][::-1].tolist())
  print(r)

numpy_boundary_traverse(a)
##q2
import numpy as np
a=10*np.random.rand(20)
print(a)
b = np.round(a,2)
print(b)
p=np.min(b)
q=np.max(b)
r=np.median(b)
print(p,q,r)
b[b<5]=b[b<5]*b[b<5]
print(b)

def numpy_alternate_sort(array):
   sorted_array = np.sort(array)
   result = np.empty_like(sorted_array)
   left = 0
   right = len(sorted_array) - 1

   for i in range(len(sorted_array)):
    if i % 2 == 0:
      result[i] = sorted_array[left]
      left += 1
    else:
        result[i] = sorted_array[right]
        right -= 1
   print(result)

numpy_alternate_sort(a)
##Q3
import numpy as np
import pandas as pd

data = {
    'Name': [f'Student {i}' for i in range(1, 11)],
    'Subject': np.random.choice(['Math', 'Science', 'English'], 10),
    'Score': np.random.randint(50, 101, 10),
    'Grade': ['' for _ in range(10)]
}

df = pd.DataFrame(data)
print(df)

def assign_grade(score):
    if score >= 90:
        return 'A'
    elif score >= 80:
        return 'B'
    elif score >= 70:
        return 'C'
    elif score >= 60:
        return 'D'
    else:
        return 'F'
df['Grade'] = df['Score'].apply(assign_grade)
print(df)

df_sorted = df.sort_values(by='Score', ascending=False)
print(df_sorted)

average_scores = df.groupby('Subject')['Score'].mean()
print(average_scores)

def pandas_filter_pass(df):
  filtered_df = df[df["Score"] >= 80]
  print(filtered_df)

pandas_filter_pass(df)
##q4
import numpy as np
import pandas as pd
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.model_selection import train_test_split
from sklearn.naive_bayes import MultinomialNB
from sklearn.metrics import accuracy_score
positive_reviews = [
    "Excellent product, works perfectly",
    "Very happy with this purchase",
    "Great quality for the price",
    "Fast shipping and good packaging",
    "Exactly what I was looking for",
    "Highly recommend this item",
    "Perfect fit and comfortable",
    "Works better than expected",
    "Customer service was outstanding",
    "Will definitely buy again"
]

negative_reviews = [
    "Poor quality, broke immediately",
    "Not as described in the listing",
    "Terrible customer service",
    "Overpriced for what you get",
    "Arrived damaged and unusable",
    "Wrong item was delivered",
    "Much smaller than expected",
    "Doesn't work properly",
    "Waste of money",
    "Would not recommend to anyone"
]

reviews = []
labels = []
for _ in range(50):
    reviews.append(np.random.choice(positive_reviews))
    labels.append(1)
    reviews.append(np.random.choice(negative_reviews))
    labels.append(0)

data = list(zip(reviews, labels))
np.random.shuffle(data)
reviews, labels = zip(*data)


vectorizer = CountVectorizer(max_features=500, stop_words='english')
X = vectorizer.fit_transform(reviews)
y = np.array(labels)

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)


model = MultinomialNB()
model.fit(X_train, y_train)


y_pred = model.predict(X_test)
accuracy = accuracy_score(y_test, y_pred)
print(f"Test Accuracy: {accuracy:.4f}")


def predict_review_sentiment(model, vectorizer, review):
    review_vec = vectorizer.transform([review])
    prediction = model.predict(review_vec)
    return prediction

sample_review = "Perfect"
prediction = predict_review_sentiment(model, vectorizer, sample_review)
print(f"Predicted sentiment: {'Positive' if prediction == 1 else 'Negative'}")
##Q5
import numpy as np
import pandas as pd
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import precision_score, recall_score, f1_score

positive_feedback = [
    "Great product, works perfectly",
    "Very satisfied with this purchase",
    "Excellent quality for the price",
    "Fast shipping and good packaging",
    "Exactly what I needed",
    "Highly recommend this product",
    "Perfect fit and comfortable",
    "Exceeded my expectations",
    "Customer service was excellent",
    "Will definitely buy again",
    "Works flawlessly",
    "Better than I imagined",
    "Great value for money",
    "Arrived earlier than expected",
    "Very impressed with the quality"
]

negative_feedback = [
    "Poor quality, broke immediately",
    "Not as described",
    "Terrible customer service",
    "Overpriced for what you get",
    "Arrived damaged",
    "Wrong item was delivered",
    "Much smaller than expected",
    "Doesn't work properly",
    "Waste of money",
    "Would not recommend",
    "Defective product",
    "Shipping took too long",
    "Not worth the price",
    "Missing parts",
    "Very disappointed"
]

feedback_samples = []
labels = []
for _ in range(50):  # 50 good and 50 bad samples
    feedback_samples.append(np.random.choice(positive_feedback))
    labels.append(1)
    feedback_samples.append(np.random.choice(negative_feedback))
    labels.append(0)

data = list(zip(feedback_samples, labels))
np.random.shuffle(data)
feedback_samples, labels = zip(*data)

vectorizer = TfidfVectorizer(max_features=300, stop_words='english', lowercase=True)
X = vectorizer.fit_transform(feedback_samples)
y = np.array(labels)

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25, random_state=42)

model = LogisticRegression(random_state=42)
model.fit(X_train, y_train)

y_pred = model.predict(X_test)

precision = precision_score(y_test, y_pred)
recall = recall_score(y_test, y_pred)
f1 = f1_score(y_test, y_pred)

print(f"Precision: {precision:.4f}")
print(f"Recall: {recall:.4f}")
print(f"F1-score: {f1:.4f}")

def text_preprocess_vectorize(texts, vectorizer):
    return vectorizer.transform(texts)

new_texts = ["This product is amazing!", "Terrible experience, never buying again"]
vectorized_texts = text_preprocess_vectorize(new_texts, vectorizer)
print(vectorized_texts)